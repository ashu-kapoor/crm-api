/****************
Generated by NODEBOOTSTRAPPER
Author: Ashutosh Kapoor
GIT LINK : https://github.com/ashu-kapoor/NODEBOOTSTRAPPER
****************/
const errorMiddleare = require("./middlewares/errorHandler");
const { loadApp } = require("./loadApp");
const routes = require("./routes");
const mongoose = require("mongoose");
const multer = require("multer");
const { uuid } = require("uuidv4");
const userValidator = require("./validators/userValidator");
const productValidator = require("./validators/productValidator");
const path = require("path");
require("dotenv").config({ path: path.join(__dirname, ".env") });

const {
  validateCreateOpportunity,
  validateUpdateOpportunity,
} = require("./validators/opportunityValidator");

const {
  validateCreateContact,
  validateUpdateContact,
} = require("./validators/contactValidator");

const {
  validateCreateCase,
  validateUpdateCase,
} = require("./validators/caseValidator");

//by default register all routes
//Routes to register, Array of custom middlewares to be applied to all routes
//and options and dbconnection promise

//Multer configuration
const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "fileStorage");
  },
  filename: (req, file, cb) => {
    cb(null, uuid() + "_" + file.originalname);
  },
});

const fileFilter = (req, file, cb) => {
  if (file.mimetype == "text/plain") {
    cb(null, true);
  } else {
    const error = new Error();
    error.apiErrorCode = 1600;
    customError.apiData = "fileData";
    cb(error, false);
  }
};

const routesArray = [
  {
    method: routes.authUserRoute.authUser,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.createUserRoute.createUser,
    validatorFn: userValidator,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getUsersRoute.getUsers,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getUserRoute.getUser,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.updateUserRoute.updateUser,
    validatorFn: userValidator,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.deleteUserRoute.deleteUser,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.createProductRoute.createProduct,
    validatorFn: productValidator,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getProductsRoute.getProducts,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getProductRoute.getProduct,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.updateProductRoute.updateProduct,
    validatorFn: productValidator,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.deleteProductRoute.deleteProduct,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.createContactRoute.createContact,
    validatorFn: validateCreateContact,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getContactsRoute.getContacts,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getContactRoute.getContact,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.updateContactRoute.updateContact,
    validatorFn: validateUpdateContact,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.deleteContactRoute.deleteContact,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.createOpportunityRoute.createOpportunity,
    validatorFn: validateCreateOpportunity,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getOpportunitiesRoute.getOpportunities,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getOpportunityRoute.getOpportunity,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.updateOpportunityRoute.updateOpportunity,
    validatorFn: validateUpdateOpportunity,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.deleteOpportunityRoute.deleteOpportunity,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getAllOptiesRoute.getAllOpties,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.createCaseRoute.createCase,
    validatorFn: validateCreateCase,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getCasesRoute.getCases,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.updateCaseRoute.updateCase,
    validatorFn: validateUpdateCase,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.deleteCaseRoute.deleteCase,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getCaseRoute.getCase,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.getAllCasesRoute.getAllCases,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.createAttachmentRoute.createAttachment,
    validatorFn: null,
    routeSpecificMiddlewares: [
      multer({
        storage: fileStorage,
        fileFilter: fileFilter,
      }).single("uploadedFile"),
    ],
  },
  {
    method: routes.getAttachmentRoute.getAttachment,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
  {
    method: routes.deleteAttachmentRoute.deleteAttachment,
    validatorFn: null,
    routeSpecificMiddlewares: null,
  },
];

const options = {
  useNoCache: true,
  allowCORSOrigin: "*",
  multiparserConfig: null,
  port: process.env.port,
  useJsonParser: true,
  useUrlEncodedParser: false,
};

const dbConnectionPromise = mongoose.connect(process.env.connectionURL);
mongoose.set("debug", process.env.debugMongo);
/**
 * @param {array} routesArray - routesArray to register
 * @param {array} customMiddlewares - array of custom middlewares to be applied to this route
 * @param {array} postMiddlewares - array of middlewares to be applied after all routes
 * @param {object} options - options object deafault value are : {useNoCache:true, allowCORSOrigin:'*', multiparserConfig=null, port=8080}, dbConnectionPromise=null)
 * @param {object} dbConnectionPromise - promise if connection to DB on which to start server
 **/
loadApp(routesArray, [], [errorMiddleare], options, dbConnectionPromise);
